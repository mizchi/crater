// Generated by `wit-bindgen` 0.47.0. DO NOT EDIT!
pub extern "wasm" fn extend16(value : Int) -> Int =
#|(func (param i32) (result i32) local.get 0 i32.extend16_s)

pub extern "wasm" fn extend8(value : Int) -> Int =
#|(func (param i32) (result i32) local.get 0 i32.extend8_s)

pub extern "wasm" fn store8(offset : Int, value : Int) =
#|(func (param i32) (param i32) local.get 0 local.get 1 i32.store8)

pub extern "wasm" fn load8_u(offset : Int) -> Int =
#|(func (param i32) (result i32) local.get 0 i32.load8_u)

pub extern "wasm" fn load8(offset : Int) -> Int =
#|(func (param i32) (result i32) local.get 0 i32.load8_s)

pub extern "wasm" fn store16(offset : Int, value : Int) =
#|(func (param i32) (param i32) local.get 0 local.get 1 i32.store16)

pub extern "wasm" fn load16(offset : Int) -> Int =
#|(func (param i32) (result i32) local.get 0 i32.load16_s)

pub extern "wasm" fn load16_u(offset : Int) -> Int =
#|(func (param i32) (result i32) local.get 0 i32.load16_u)

pub extern "wasm" fn store32(offset : Int, value : Int) =
#|(func (param i32) (param i32) local.get 0 local.get 1 i32.store)

pub extern "wasm" fn load32(offset : Int) -> Int =
#|(func (param i32) (result i32) local.get 0 i32.load)

pub extern "wasm" fn store64(offset : Int, value : Int64) =
#|(func (param i32) (param i64) local.get 0 local.get 1 i64.store)

pub extern "wasm" fn load64(offset : Int) -> Int64 =
#|(func (param i32) (result i64) local.get 0 i64.load)

pub extern "wasm" fn storef32(offset : Int, value : Float) =
#|(func (param i32) (param f32) local.get 0 local.get 1 f32.store)

pub extern "wasm" fn loadf32(offset : Int) -> Float =
#|(func (param i32) (result f32) local.get 0 f32.load)

pub extern "wasm" fn storef64(offset : Int, value : Double) =
#|(func (param i32) (param f64) local.get 0 local.get 1 f64.store)

pub extern "wasm" fn loadf64(offset : Int) -> Double =
#|(func (param i32) (result f64) local.get 0 f64.load)

pub extern "wasm" fn f32_to_i32(value : Float) -> Int =
#|(func (param f32) (result i32) local.get 0 f32.convert_i32_s)

pub extern "wasm" fn f32_to_i64(value : Float) -> Int64 =
#|(func (param f32) (result i64) local.get 0 f32.convert_i64_s)

// set pseudo header; allocate extra bytes for string
pub extern "wasm" fn malloc(size : Int) -> Int =
#|(func (param i32) (result i32) (local i32)
#| local.get 0 i32.const 4 i32.add call $moonbit.gc.malloc
#| local.tee 1 i32.const 0 call $moonbit.init_array8
#| local.get 1 i32.const 8 i32.add)

pub extern "wasm" fn free(position : Int) =
#|(func (param i32) local.get 0 i32.const 8 i32.sub call $moonbit.decref)

extern "wasm" fn copy(dest : Int, src : Int, len : Int) =
#|(func (param i32) (param i32) (param i32) local.get 0 local.get 1 local.get 2 memory.copy)

pub extern "wasm" fn str2ptr(str : String) -> Int =
#|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

pub extern "wasm" fn ptr2str(ptr : Int, len : Int) -> String =
#|(func (param i32) (param i32) (result i32) (local i32)
#| local.get 0 i32.const 8 i32.sub local.tee 2
#| local.get 1 call $moonbit.init_array16
#| local.get 2)

pub extern "wasm" fn bytes2ptr(bytes : FixedArray[Byte]) -> Int =
#|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

pub extern "wasm" fn ptr2bytes(ptr : Int, len : Int) -> FixedArray[Byte] =
#|(func (param i32) (param i32) (result i32) (local i32)
#| local.get 0 i32.const 8 i32.sub local.tee 2
#| local.get 1 call $moonbit.init_array8
#| local.get 2)

pub extern "wasm" fn uint_array2ptr(array : FixedArray[UInt]) -> Int =
#|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

pub extern "wasm" fn uint64_array2ptr(array : FixedArray[UInt64]) -> Int =
#|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

pub extern "wasm" fn int_array2ptr(array : FixedArray[Int]) -> Int =
#|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

pub extern "wasm" fn int64_array2ptr(array : FixedArray[Int64]) -> Int =
#|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

pub extern "wasm" fn float_array2ptr(array : FixedArray[Float]) -> Int =
#|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

pub extern "wasm" fn double_array2ptr(array : FixedArray[Double]) -> Int =
#|(func (param i32) (result i32) local.get 0 i32.const 8 i32.add)

pub extern "wasm" fn ptr2uint_array(ptr : Int, len : Int) -> FixedArray[UInt] =
#|(func (param i32) (param i32) (result i32) (local i32)
#| local.get 0 i32.const 8 i32.sub local.tee 2
#| local.get 1 call $moonbit.init_array32
#| local.get 2)

pub extern "wasm" fn ptr2int_array(ptr : Int, len : Int) -> FixedArray[Int] =
#|(func (param i32) (param i32) (result i32) (local i32)
#| local.get 0 i32.const 8 i32.sub local.tee 2
#| local.get 1 call $moonbit.init_array32
#| local.get 2)

pub extern "wasm" fn ptr2float_array(ptr : Int, len : Int) -> FixedArray[Float] =
#|(func (param i32) (param i32) (result i32) (local i32)
#| local.get 0 i32.const 8 i32.sub local.tee 2
#| local.get 1 call $moonbit.init_array32
#| local.get 2)

pub extern "wasm" fn ptr2uint64_array(ptr : Int, len : Int) -> FixedArray[UInt64] =
#|(func (param i32) (param i32) (result i32) (local i32)
#| local.get 0 i32.const 8 i32.sub local.tee 2
#| local.get 1 call $moonbit.init_array64
#| local.get 2)

pub extern "wasm" fn ptr2int64_array(ptr : Int, len : Int) -> FixedArray[Int64] =
#|(func (param i32) (param i32) (result i32) (local i32)
#| local.get 0 i32.const 8 i32.sub local.tee 2
#| local.get 1 call $moonbit.init_array64
#| local.get 2)

pub extern "wasm" fn ptr2double_array(ptr : Int, len : Int) -> FixedArray[Double] =
#|(func (param i32) (param i32) (result i32) (local i32)
#| local.get 0 i32.const 8 i32.sub local.tee 2
#| local.get 1 call $moonbit.init_array64
#| local.get 2)

pub fn cabi_realloc(
src_offset : Int,
src_size : Int,
_dst_alignment : Int,
dst_size : Int
) -> Int {{
      // malloc
      if src_offset == 0 && src_size == 0 {{
            return malloc(dst_size)
      }}
      // free
      if dst_size == 0 {{
            free(src_offset)
            return 0
      }}
      // realloc
      let dst = malloc(dst_size)
      copy(dst, src_offset, if src_size < dst_size { src_size } else { dst_size })
      free(src_offset)
      dst
}}

pub(open) trait Any {}
pub(all) struct Cleanup {
      address : Int
      size : Int
      align : Int
}

///|
/// Convert UTF-16 bytes from component model to MoonBit String
/// ptr points to UTF-16 code units, len is number of code units
pub fn utf16_ptr2str(ptr : Int, len : Int) -> String {
  let buf = StringBuilder::new()
  for i = 0; i < len; i = i + 1 {
    let ch = load16_u(ptr + i * 2)
    buf.write_char(Char::from_int(ch))
  }
  buf.to_string()
}

///|
/// Convert UTF-8 bytes from component model to MoonBit String (UTF-16)
pub fn utf8_ptr2str(ptr : Int, len : Int) -> String {
  // Build string from UTF-8 bytes
  let buf = StringBuilder::new()
  let mut i = 0
  while i < len {
    let b0 = load8_u(ptr + i)
    if b0 < 0x80 {
      // ASCII
      buf.write_char(Char::from_int(b0))
      i = i + 1
    } else if b0 < 0xE0 {
      // 2-byte sequence
      let b1 = load8_u(ptr + i + 1)
      let cp = ((b0 & 0x1F) << 6) | (b1 & 0x3F)
      buf.write_char(Char::from_int(cp))
      i = i + 2
    } else if b0 < 0xF0 {
      // 3-byte sequence
      let b1 = load8_u(ptr + i + 1)
      let b2 = load8_u(ptr + i + 2)
      let cp = ((b0 & 0x0F) << 12) | ((b1 & 0x3F) << 6) | (b2 & 0x3F)
      buf.write_char(Char::from_int(cp))
      i = i + 3
    } else {
      // 4-byte sequence
      let b1 = load8_u(ptr + i + 1)
      let b2 = load8_u(ptr + i + 2)
      let b3 = load8_u(ptr + i + 3)
      let cp = ((b0 & 0x07) << 18) | ((b1 & 0x3F) << 12) | ((b2 & 0x3F) << 6) | (b3 & 0x3F)
      buf.write_char(Char::from_int(cp))
      i = i + 4
    }
  }
  buf.to_string()
}

///|
/// Convert MoonBit String (UTF-16) to UTF-16 bytes for component model
/// Returns (ptr, len) where ptr points to UTF-16 code units and len is number of code units
pub fn str2utf16(s : String) -> (Int, Int) {
  // MoonBit String is already UTF-16 internally
  let len = s.length()
  // Allocate memory for UTF-16 code units (2 bytes each)
  let ptr = malloc(len * 2)
  // Write UTF-16 code units
  for i = 0; i < len; i = i + 1 {
    let ch = s[i].to_int()
    store16(ptr + i * 2, ch)
  }
  (ptr, len)
}

///|
/// Convert MoonBit String (UTF-16) to UTF-8 bytes for component model
/// Returns (ptr, len) where ptr points to UTF-8 bytes
pub fn str2utf8(s : String) -> (Int, Int) {
  // First pass: calculate UTF-8 length
  let mut utf8_len = 0
  for c in s {
    let cp = c.to_int()
    if cp < 0x80 {
      utf8_len = utf8_len + 1
    } else if cp < 0x800 {
      utf8_len = utf8_len + 2
    } else if cp < 0x10000 {
      utf8_len = utf8_len + 3
    } else {
      utf8_len = utf8_len + 4
    }
  }
  // Allocate memory
  let ptr = malloc(utf8_len)
  // Second pass: write UTF-8 bytes
  let mut i = 0
  for c in s {
    let cp = c.to_int()
    if cp < 0x80 {
      store8(ptr + i, cp)
      i = i + 1
    } else if cp < 0x800 {
      store8(ptr + i, 0xC0 | (cp >> 6))
      store8(ptr + i + 1, 0x80 | (cp & 0x3F))
      i = i + 2
    } else if cp < 0x10000 {
      store8(ptr + i, 0xE0 | (cp >> 12))
      store8(ptr + i + 1, 0x80 | ((cp >> 6) & 0x3F))
      store8(ptr + i + 2, 0x80 | (cp & 0x3F))
      i = i + 3
    } else {
      store8(ptr + i, 0xF0 | (cp >> 18))
      store8(ptr + i + 1, 0x80 | ((cp >> 12) & 0x3F))
      store8(ptr + i + 2, 0x80 | ((cp >> 6) & 0x3F))
      store8(ptr + i + 3, 0x80 | (cp & 0x3F))
      i = i + 4
    }
  }
  (ptr, utf8_len)
}
