/**
 * CDP WebSocket Server
 *
 * WebSocket server for Chrome DevTools Protocol.
 * Connects puppeteer-core to the MoonBit CDP implementation.
 *
 * Usage:
 *   npx tsx tools/cdp-server.ts [port]
 *
 * Default port: 9222
 */

import { WebSocketServer, WebSocket } from 'ws';
import { createServer, IncomingMessage, ServerResponse } from 'http';

// Import the MoonBit CDP module
// @ts-ignore - generated by moon build
import * as cdp from '../target/js/release/build/src/cdp_js/cdp_js.js';

// Fetch URL content with response metadata
interface FetchResult {
  body: string;
  status: number;
  statusText: string;
  headers: Record<string, string>;
  mimeType: string;
}

async function fetchUrlWithMetadata(url: string): Promise<FetchResult> {
  const response = await fetch(url);
  const body = await response.text();

  // Extract headers
  const headers: Record<string, string> = {};
  response.headers.forEach((value, key) => {
    headers[key] = value;
  });

  // Get MIME type from Content-Type header
  const contentType = response.headers.get('content-type') || 'text/html';
  const mimeType = contentType.split(';')[0].trim();

  return {
    body,
    status: response.status,
    statusText: response.statusText,
    headers,
    mimeType,
  };
}

const PORT = parseInt(process.argv[2] || '9222', 10);

// Track active connections
const connections = new Set<WebSocket>();

// HTTP server for /json endpoints (required by puppeteer)
const httpServer = createServer((req: IncomingMessage, res: ServerResponse) => {
  const url = req.url || '/';
  console.log(`HTTP ${req.method} ${url}`);

  res.setHeader('Content-Type', 'application/json');

  if (url === '/json/version') {
    res.end(JSON.stringify({
      Browser: 'Crater/1.0',
      'Protocol-Version': '1.3',
      'User-Agent': 'Crater',
      'V8-Version': '0.0.0',
      'WebKit-Version': '0.0.0',
      webSocketDebuggerUrl: `ws://localhost:${PORT}/devtools/browser`,
    }));
    return;
  }

  if (url === '/json' || url === '/json/list') {
    res.end(JSON.stringify([{
      description: '',
      devtoolsFrontendUrl: '',
      id: 'page-1',
      title: 'Crater Page',
      type: 'page',
      url: 'about:blank',
      webSocketDebuggerUrl: `ws://localhost:${PORT}/devtools/page/page-1`,
    }]));
    return;
  }

  if (url === '/json/new') {
    res.end(JSON.stringify({
      description: '',
      devtoolsFrontendUrl: '',
      id: 'page-1',
      title: 'Crater Page',
      type: 'page',
      url: 'about:blank',
      webSocketDebuggerUrl: `ws://localhost:${PORT}/devtools/page/page-1`,
    }));
    return;
  }

  res.statusCode = 404;
  res.end(JSON.stringify({ error: 'Not found' }));
});

// WebSocket server
const wss = new WebSocketServer({ server: httpServer });

wss.on('connection', (ws: WebSocket, req: IncomingMessage) => {
  console.log(`WebSocket connection: ${req.url}`);
  connections.add(ws);

  // Reset protocol state for new connection
  cdp.resetCdpProtocol();

  ws.on('message', async (data: Buffer) => {
    const message = data.toString();
    console.log(`<- ${message.substring(0, 200)}${message.length > 200 ? '...' : ''}`);

    try {
      // Parse message to check for Page.navigate
      const parsed = JSON.parse(message);

      // Handle Page.navigate specially - fetch the URL content
      if (parsed.method === 'Page.navigate' && parsed.params?.url) {
        const url = parsed.params.url;
        const sessionId = parsed.sessionId || '';
        console.log(`[Navigate] Fetching ${url}...`);

        // Use consistent frame and loader IDs - generate loaderId first for consistency
        const frameId = 'TID-1'; // Current target ID
        const loaderId = `loader-${Date.now()}`;

        // Create network request with explicit loaderId (triggers Network.requestWillBeSent)
        const requestId = cdp.createNetworkRequestWithLoader(url, 'Document', url, frameId, loaderId);
        console.log(`[Navigate] Created network request ${requestId} with loader ${loaderId}`);

        // Flush network events (sends Network.requestWillBeSent)
        cdp.flushNetworkEvents(sessionId);
        sendPendingMessages(ws);

        try {
          // Fetch the URL content with metadata
          const result = await fetchUrlWithMetadata(url);
          console.log(`[Navigate] Fetched ${result.body.length} bytes (status: ${result.status})`);

          // Notify response received with loaderId (triggers Network.responseReceived)
          cdp.notifyResponseReceivedWithLoader(
            requestId,
            url,
            result.status,
            result.mimeType,
            JSON.stringify(result.headers),
            loaderId
          );

          // Flush network events (sends Network.responseReceived)
          cdp.flushNetworkEvents(sessionId);
          sendPendingMessages(ws);

          // Load HTML into MoonBit
          cdp.loadHtmlContent(result.body);

          // Notify loading finished (triggers Network.loadingFinished)
          cdp.notifyLoadingFinished(requestId, result.body.length);

          // Flush network events (sends Network.loadingFinished)
          cdp.flushNetworkEvents(sessionId);
          sendPendingMessages(ws);

          // Extract title from HTML for context
          const titleMatch = result.body.match(/<title[^>]*>([^<]*)<\/title>/i);
          const title = titleMatch ? titleMatch[1] : url;

          // Clear old execution contexts
          const contextsClearedEvent = JSON.stringify({
            method: 'Runtime.executionContextsCleared',
            params: {},
            sessionId: parsed.sessionId,
          });
          console.log(`-> [event] Runtime.executionContextsCleared`);
          ws.send(contextsClearedEvent);

          // Send Page.frameStartedLoading first
          const frameStartedEvent = JSON.stringify({
            method: 'Page.frameStartedLoading',
            params: { frameId: frameId },
            sessionId: parsed.sessionId,
          });
          console.log(`-> [event] Page.frameStartedLoading`);
          ws.send(frameStartedEvent);

          // Construct our own navigate response with consistent IDs
          const navigateResponse = JSON.stringify({
            id: parsed.id,
            result: {
              frameId: frameId,
              loaderId: loaderId,
            },
            sessionId: parsed.sessionId,
          });
          console.log(`-> ${navigateResponse.substring(0, 200)}${navigateResponse.length > 200 ? '...' : ''}`);
          ws.send(navigateResponse);

          // Process through MoonBit to update internal state (but don't send its response)
          cdp.processCdpMessage(message);
          // Clear any pending messages from MoonBit (we handle events ourselves)
          while (cdp.hasPendingCdpMessages() > 0) {
            cdp.getNextCdpMessage();
          }

          // Send Page.frameNavigated event
          const frameNavigatedEvent = JSON.stringify({
            method: 'Page.frameNavigated',
            params: {
              frame: {
                id: frameId,
                loaderId: loaderId,
                url: url,
                urlFragment: '',
                domainAndRegistry: new URL(url).hostname,
                securityOrigin: new URL(url).origin,
                mimeType: 'text/html',
                secureContextType: 'Secure',
                crossOriginIsolatedContextType: 'NotIsolated',
                gatedAPIFeatures: [],
              },
              type: 'Navigation',
            },
            sessionId: parsed.sessionId,
          });
          console.log(`-> [event] ${frameNavigatedEvent.substring(0, 200)}...`);
          ws.send(frameNavigatedEvent);

          // Send lifecycle events (init is required to update frame._loaderId in puppeteer)
          const lifecycleEvents = ['init', 'commit', 'DOMContentLoaded', 'load', 'networkAlmostIdle', 'networkIdle'];
          for (const name of lifecycleEvents) {
            const event = JSON.stringify({
              method: 'Page.lifecycleEvent',
              params: {
                frameId: frameId,
                loaderId: loaderId,
                name: name,
                timestamp: Date.now() / 1000,
              },
              sessionId: parsed.sessionId,
            });
            console.log(`-> [event] Page.lifecycleEvent: ${name} (loaderId: ${loaderId})`);
            ws.send(event);
          }

          // Send Page.domContentEventFired
          const domContentEvent = JSON.stringify({
            method: 'Page.domContentEventFired',
            params: { timestamp: Date.now() / 1000 },
            sessionId: parsed.sessionId,
          });
          console.log(`-> [event] Page.domContentEventFired`);
          ws.send(domContentEvent);

          // Send Page.loadEventFired
          const loadEvent = JSON.stringify({
            method: 'Page.loadEventFired',
            params: { timestamp: Date.now() / 1000 },
            sessionId: parsed.sessionId,
          });
          console.log(`-> [event] Page.loadEventFired`);
          ws.send(loadEvent);

          // Create new execution contexts for the new page
          const mainContextEvent = JSON.stringify({
            method: 'Runtime.executionContextCreated',
            params: {
              context: {
                id: 3, // New context ID after navigation
                origin: new URL(url).origin,
                name: '',
                uniqueId: '-3',
                auxData: {
                  isDefault: true,
                  type: 'default',
                  frameId: frameId,
                },
              },
            },
            sessionId: parsed.sessionId,
          });
          console.log(`-> [event] Runtime.executionContextCreated (main)`);
          ws.send(mainContextEvent);

          const isolatedContextEvent = JSON.stringify({
            method: 'Runtime.executionContextCreated',
            params: {
              context: {
                id: 4, // New isolated context
                origin: new URL(url).origin,
                name: '__puppeteer_utility_world__24.34.0',
                uniqueId: '-4',
                auxData: {
                  isDefault: false,
                  type: 'isolated',
                  frameId: frameId,
                },
              },
            },
            sessionId: parsed.sessionId,
          });
          console.log(`-> [event] Runtime.executionContextCreated (isolated)`);
          ws.send(isolatedContextEvent);

          // Send Page.frameStoppedLoading
          const frameStoppedEvent = JSON.stringify({
            method: 'Page.frameStoppedLoading',
            params: { frameId: frameId },
            sessionId: parsed.sessionId,
          });
          console.log(`-> [event] Page.frameStoppedLoading`);
          ws.send(frameStoppedEvent);

        } catch (fetchError) {
          console.error(`[Navigate] Fetch error:`, fetchError);

          // Notify loading failed (triggers Network.loadingFailed)
          cdp.notifyLoadingFailed(requestId, String(fetchError));

          // Flush network events (sends Network.loadingFailed)
          cdp.flushNetworkEvents(sessionId);
          sendPendingMessages(ws);

          // Send error response
          ws.send(JSON.stringify({
            id: parsed.id,
            error: { code: -32000, message: `Failed to fetch ${url}: ${fetchError}` },
            sessionId: parsed.sessionId,
          }));
        }
        return;
      }

      // Process message through MoonBit CDP
      const response = cdp.processCdpMessage(message);
      console.log(`-> ${response.substring(0, 200)}${response.length > 200 ? '...' : ''}`);
      ws.send(response);

      // Send any pending messages (events)
      sendPendingMessages(ws);
    } catch (err) {
      console.error('Error processing message:', err);
      const errorResponse = JSON.stringify({
        error: { code: -32603, message: String(err) }
      });
      ws.send(errorResponse);
    }
  });

  function sendPendingMessages(ws: WebSocket) {
    let pending = cdp.hasPendingCdpMessages();
    while (pending > 0) {
      const pendingMsg = cdp.getNextCdpMessage();
      if (pendingMsg) {
        console.log(`-> [event] ${pendingMsg.substring(0, 200)}${pendingMsg.length > 200 ? '...' : ''}`);
        ws.send(pendingMsg);
      }
      pending = cdp.hasPendingCdpMessages();
    }
  }

  ws.on('close', () => {
    console.log('WebSocket closed');
    connections.delete(ws);
  });

  ws.on('error', (err) => {
    console.error('WebSocket error:', err);
  });
});

httpServer.listen(PORT, () => {
  console.log(`Crater CDP server listening on port ${PORT}`);
  console.log(`WebSocket: ws://localhost:${PORT}/devtools/browser`);
  console.log(`HTTP API: http://localhost:${PORT}/json/version`);
  console.log(`\nConnect with puppeteer-core:`);
  console.log(`  const browser = await puppeteer.connect({`);
  console.log(`    browserWSEndpoint: 'ws://localhost:${PORT}/devtools/browser'`);
  console.log(`  });`);
});
