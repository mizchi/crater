/**
 * CDP WebSocket Server
 *
 * WebSocket server for Chrome DevTools Protocol.
 * Connects puppeteer-core to the MoonBit CDP implementation.
 *
 * Usage:
 *   npx tsx tools/cdp-server.ts [port]
 *
 * Default port: 9222
 */

import { WebSocketServer, WebSocket } from 'ws';
import { createServer, IncomingMessage, ServerResponse } from 'http';

// Import the MoonBit CDP module
// @ts-ignore - generated by moon build
import * as cdp from '../target/js/release/build/src/cdp_js/cdp_js.js';

// Fetch URL content
async function fetchUrl(url: string): Promise<string> {
  const response = await fetch(url);
  return response.text();
}

const PORT = parseInt(process.argv[2] || '9222', 10);

// Track active connections
const connections = new Set<WebSocket>();

// HTTP server for /json endpoints (required by puppeteer)
const httpServer = createServer((req: IncomingMessage, res: ServerResponse) => {
  const url = req.url || '/';
  console.log(`HTTP ${req.method} ${url}`);

  res.setHeader('Content-Type', 'application/json');

  if (url === '/json/version') {
    res.end(JSON.stringify({
      Browser: 'Crater/1.0',
      'Protocol-Version': '1.3',
      'User-Agent': 'Crater',
      'V8-Version': '0.0.0',
      'WebKit-Version': '0.0.0',
      webSocketDebuggerUrl: `ws://localhost:${PORT}/devtools/browser`,
    }));
    return;
  }

  if (url === '/json' || url === '/json/list') {
    res.end(JSON.stringify([{
      description: '',
      devtoolsFrontendUrl: '',
      id: 'page-1',
      title: 'Crater Page',
      type: 'page',
      url: 'about:blank',
      webSocketDebuggerUrl: `ws://localhost:${PORT}/devtools/page/page-1`,
    }]));
    return;
  }

  if (url === '/json/new') {
    res.end(JSON.stringify({
      description: '',
      devtoolsFrontendUrl: '',
      id: 'page-1',
      title: 'Crater Page',
      type: 'page',
      url: 'about:blank',
      webSocketDebuggerUrl: `ws://localhost:${PORT}/devtools/page/page-1`,
    }));
    return;
  }

  res.statusCode = 404;
  res.end(JSON.stringify({ error: 'Not found' }));
});

// WebSocket server
const wss = new WebSocketServer({ server: httpServer });

wss.on('connection', (ws: WebSocket, req: IncomingMessage) => {
  console.log(`WebSocket connection: ${req.url}`);
  connections.add(ws);

  // Reset protocol state for new connection
  cdp.resetCdpProtocol();

  ws.on('message', async (data: Buffer) => {
    const message = data.toString();
    console.log(`<- ${message.substring(0, 200)}${message.length > 200 ? '...' : ''}`);

    try {
      // Parse message to check for Page.navigate
      const parsed = JSON.parse(message);

      // Handle Page.navigate specially - fetch the URL content
      if (parsed.method === 'Page.navigate' && parsed.params?.url) {
        const url = parsed.params.url;
        console.log(`[Navigate] Fetching ${url}...`);

        try {
          // Fetch the URL content
          const html = await fetchUrl(url);
          console.log(`[Navigate] Fetched ${html.length} bytes`);

          // Load HTML into MoonBit
          cdp.loadHtmlContent(html);

          // Extract title from HTML for context
          const titleMatch = html.match(/<title[^>]*>([^<]*)<\/title>/i);
          const title = titleMatch ? titleMatch[1] : url;

          // Use consistent frame and loader IDs
          const frameId = 'TID-1'; // Current target ID
          const loaderId = `loader-${Date.now()}`;

          // Clear old execution contexts
          const contextsClearedEvent = JSON.stringify({
            method: 'Runtime.executionContextsCleared',
            params: {},
            sessionId: parsed.sessionId,
          });
          console.log(`-> [event] Runtime.executionContextsCleared`);
          ws.send(contextsClearedEvent);

          // Send Page.frameStartedLoading first
          const frameStartedEvent = JSON.stringify({
            method: 'Page.frameStartedLoading',
            params: { frameId: frameId },
            sessionId: parsed.sessionId,
          });
          console.log(`-> [event] Page.frameStartedLoading`);
          ws.send(frameStartedEvent);

          // Construct our own navigate response with consistent IDs
          const navigateResponse = JSON.stringify({
            id: parsed.id,
            result: {
              frameId: frameId,
              loaderId: loaderId,
            },
            sessionId: parsed.sessionId,
          });
          console.log(`-> ${navigateResponse.substring(0, 200)}${navigateResponse.length > 200 ? '...' : ''}`);
          ws.send(navigateResponse);

          // Process through MoonBit to update internal state (but don't send its response)
          cdp.processCdpMessage(message);
          // Clear any pending messages from MoonBit (we handle events ourselves)
          while (cdp.hasPendingCdpMessages() > 0) {
            cdp.getNextCdpMessage();
          }

          // Send Page.frameNavigated event
          const frameNavigatedEvent = JSON.stringify({
            method: 'Page.frameNavigated',
            params: {
              frame: {
                id: frameId,
                loaderId: loaderId,
                url: url,
                securityOrigin: new URL(url).origin,
                mimeType: 'text/html',
              }
            },
            sessionId: parsed.sessionId,
          });
          console.log(`-> [event] ${frameNavigatedEvent.substring(0, 200)}...`);
          ws.send(frameNavigatedEvent);

          // Send lifecycle events
          const lifecycleEvents = ['commit', 'DOMContentLoaded', 'load'];
          for (const name of lifecycleEvents) {
            const event = JSON.stringify({
              method: 'Page.lifecycleEvent',
              params: {
                frameId: frameId,
                loaderId: loaderId,
                name: name,
                timestamp: Date.now() / 1000,
              },
              sessionId: parsed.sessionId,
            });
            console.log(`-> [event] Page.lifecycleEvent: ${name}`);
            ws.send(event);
          }

          // Send Page.domContentEventFired
          const domContentEvent = JSON.stringify({
            method: 'Page.domContentEventFired',
            params: { timestamp: Date.now() / 1000 },
            sessionId: parsed.sessionId,
          });
          console.log(`-> [event] Page.domContentEventFired`);
          ws.send(domContentEvent);

          // Send Page.loadEventFired
          const loadEvent = JSON.stringify({
            method: 'Page.loadEventFired',
            params: { timestamp: Date.now() / 1000 },
            sessionId: parsed.sessionId,
          });
          console.log(`-> [event] Page.loadEventFired`);
          ws.send(loadEvent);

          // Create new execution contexts for the new page
          const mainContextEvent = JSON.stringify({
            method: 'Runtime.executionContextCreated',
            params: {
              context: {
                id: 3, // New context ID after navigation
                origin: new URL(url).origin,
                name: '',
                uniqueId: '-3',
                auxData: {
                  isDefault: true,
                  type: 'default',
                  frameId: frameId,
                },
              },
            },
            sessionId: parsed.sessionId,
          });
          console.log(`-> [event] Runtime.executionContextCreated (main)`);
          ws.send(mainContextEvent);

          const isolatedContextEvent = JSON.stringify({
            method: 'Runtime.executionContextCreated',
            params: {
              context: {
                id: 4, // New isolated context
                origin: new URL(url).origin,
                name: '__puppeteer_utility_world__24.34.0',
                uniqueId: '-4',
                auxData: {
                  isDefault: false,
                  type: 'isolated',
                  frameId: frameId,
                },
              },
            },
            sessionId: parsed.sessionId,
          });
          console.log(`-> [event] Runtime.executionContextCreated (isolated)`);
          ws.send(isolatedContextEvent);

          // Send Page.frameStoppedLoading
          const frameStoppedEvent = JSON.stringify({
            method: 'Page.frameStoppedLoading',
            params: { frameId: frameId },
            sessionId: parsed.sessionId,
          });
          console.log(`-> [event] Page.frameStoppedLoading`);
          ws.send(frameStoppedEvent);

        } catch (fetchError) {
          console.error(`[Navigate] Fetch error:`, fetchError);
          // Send error response
          ws.send(JSON.stringify({
            id: parsed.id,
            error: { code: -32000, message: `Failed to fetch ${url}: ${fetchError}` },
            sessionId: parsed.sessionId,
          }));
        }
        return;
      }

      // Process message through MoonBit CDP
      const response = cdp.processCdpMessage(message);
      console.log(`-> ${response.substring(0, 200)}${response.length > 200 ? '...' : ''}`);
      ws.send(response);

      // Send any pending messages (events)
      sendPendingMessages(ws);
    } catch (err) {
      console.error('Error processing message:', err);
      const errorResponse = JSON.stringify({
        error: { code: -32603, message: String(err) }
      });
      ws.send(errorResponse);
    }
  });

  function sendPendingMessages(ws: WebSocket) {
    let pending = cdp.hasPendingCdpMessages();
    while (pending > 0) {
      const pendingMsg = cdp.getNextCdpMessage();
      if (pendingMsg) {
        console.log(`-> [event] ${pendingMsg.substring(0, 200)}${pendingMsg.length > 200 ? '...' : ''}`);
        ws.send(pendingMsg);
      }
      pending = cdp.hasPendingCdpMessages();
    }
  }

  ws.on('close', () => {
    console.log('WebSocket closed');
    connections.delete(ws);
  });

  ws.on('error', (err) => {
    console.error('WebSocket error:', err);
  });
});

httpServer.listen(PORT, () => {
  console.log(`Crater CDP server listening on port ${PORT}`);
  console.log(`WebSocket: ws://localhost:${PORT}/devtools/browser`);
  console.log(`HTTP API: http://localhost:${PORT}/json/version`);
  console.log(`\nConnect with puppeteer-core:`);
  console.log(`  const browser = await puppeteer.connect({`);
  console.log(`    browserWSEndpoint: 'ws://localhost:${PORT}/devtools/browser'`);
  console.log(`  });`);
});
